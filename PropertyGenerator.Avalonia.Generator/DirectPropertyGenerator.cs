using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PropertyGenerator.Avalonia.Generator.Extensions;
using PropertyGenerator.Avalonia.Generator.Helpers;
using PropertyGenerator.Avalonia.Generator.Models;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static PropertyGenerator.Avalonia.Generator.Helpers.PropertyGenerationHelper;
using PropertyTuple = (Microsoft.CodeAnalysis.IPropertySymbol PropertySymbol, Microsoft.CodeAnalysis.SemanticModel SemanticModel);

namespace PropertyGenerator.Avalonia.Generator;

[Generator]
public class DirectPropertyGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "PropertyGenerator.Avalonia.GeneratedDirectPropertyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var propertySymbols = context.ForAttributeWithMetadataNameAndOptions(
                AttributeFullName,
                predicate: (node, _) =>
                {
                    // Initial check that's identical to the analyzer
                    if (!node.IsValidPropertyDeclaration())
                    {
                        return false;
                    }

                    // Make sure that all containing types are partial, otherwise declaring a partial property
                    // would not be valid. We don't need to emit diagnostics here, the compiler will handle that.
                    for (var parentNode = node.FirstAncestor<TypeDeclarationSyntax>();
                         parentNode is not null;
                         parentNode = parentNode.FirstAncestor<TypeDeclarationSyntax>())
                    {
                        if (!parentNode.Modifiers.Any(SyntaxKind.PartialKeyword))
                        {
                            return false;
                        }
                    }

                    // Here we can also easily filter out ref-returning properties just using syntax
                    return !((PropertyDeclarationSyntax) node).Type.IsKind(SyntaxKind.RefType);
                },
                transform: (ctx, _) => (PropertySymbol: (IPropertySymbol) ctx.TargetSymbol, ctx.SemanticModel))
            .Where(ctx => ctx.PropertySymbol.ContainingType is not null);

        var compilationAndProperties = context.CompilationProvider.Combine(propertySymbols.Collect());

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var ctx = source.Right;

            if (ctx.IsDefaultOrEmpty)
                return;

            foreach (var group in ctx.GroupBy<PropertyTuple, INamedTypeSymbol?>(p => p.PropertySymbol.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null || !containingClass.InheritsFromFullyQualifiedMetadataName("Avalonia.AvaloniaObject"))
                {
                    continue;
                }

                var sourceCode = GenerateClassSource(compilation, containingClass, [.. group]);
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.direct.g.cs",
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private static string GenerateClassSource(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var complicationUnit = CompilationUnit()
            .AddMembers(GenerateContent(compilation, classSymbol, properties))
            .WithLeadingTrivia(
                ParseLeadingTrivia("// <auto-generated/>\r\n")
                .Add(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                .Add(Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true))));

        return SyntaxTree(complicationUnit.NormalizeWhitespace()).ToString();
    }

    private static NamespaceDeclarationSyntax GenerateContent(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var doNotGenerateOnPropertyChangedAttributeSymbols = compilation.GetTypesByMetadataName("PropertyGenerator.Avalonia.DoNotGenerateOnPropertyChangedAttribute");
        var generateOnPropertyChanged = !classSymbol.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols)
            && !compilation.Assembly.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols);

        var classDeclaration = ClassDeclaration(className).AddModifiers(Token(SyntaxKind.PartialKeyword));
        foreach (var (property, model) in properties)
        {
            var propertyDeclaration = GenerateProperty(property, model);
            classDeclaration = classDeclaration.AddMembers(GenerateFieldDeclaration(compilation, classSymbol, property, model));
            classDeclaration = classDeclaration.AddMembers(propertyDeclaration);
            if (generateOnPropertyChanged)
                classDeclaration = classDeclaration.AddMembers(GenerateChangedMethod(property));
        }
        classDeclaration = classDeclaration.WithLeadingTrivia(ParseLeadingTrivia($"/// <inheritdoc cref=\"{className}\"/>\r\n"));
        var namespaceDeclarationSyntax = NamespaceDeclaration(ParseName(namespaceName)).AddMembers(classDeclaration);
        return namespaceDeclarationSyntax;
    }

    private static PropertyDeclarationSyntax GenerateProperty(IPropertySymbol propertySymbol, SemanticModel semanticModel)
    {
        var propertyName = propertySymbol.Name;
        var attribute = propertySymbol.GetAttributes().First(p => p.AttributeClass!.ToDisplayString() == AttributeFullName);

        var defaultValue = DefaultValueHelper.GetDefaultValue(attribute, propertySymbol, semanticModel, CancellationToken.None);

        ExpressionSyntax? initializerExpression = null;
        if (defaultValue is not AvaloniaPropertyDefaultValue.UnsetValue and not AvaloniaPropertyDefaultValue.Null)
        {
            if (defaultValue is AvaloniaPropertyDefaultValue.Callback callback)
            {
                initializerExpression = InvocationExpression(IdentifierName(callback.MethodName));
            }
            else
            {
                initializerExpression = ParseExpression(defaultValue.ToString());
            }
        }

        var property = PropertyDeclaration(propertySymbol.Type.GetTypeSyntax(), Identifier(propertyName))
            .AddModifiers(propertySymbol.DeclaredAccessibility.GetAccessibilityModifiers())
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddAccessorListAccessors(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithExpressionBody(ArrowExpressionClause(IdentifierName("field")))
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                    .WithExpressionBody(ArrowExpressionClause(
                        InvocationExpression(IdentifierName("SetAndRaise"))
                            .AddArgumentListArguments(
                                Argument(IdentifierName($"{propertyName}Property")),
                                Argument(IdentifierName("field")).WithRefOrOutKeyword(Token(SyntaxKind.RefKeyword)),
                                Argument(IdentifierName("value"))
                            )
                    ))
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            );

        if (initializerExpression != null)
        {
            property = property.WithInitializer(EqualsValueClause(initializerExpression))
                               .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
        }

        return property;
    }

    private static FieldDeclarationSyntax GenerateFieldDeclaration(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol, SemanticModel model)
    {
        var propertyName = propertySymbol.Name;
        var className = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var directPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.DirectProperty`2")!
            .Construct([classSymbol, propertySymbol.Type])
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var avaloniaPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.AvaloniaProperty")!
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var attribute = propertySymbol.GetAttributes().First(p => p.AttributeClass!.ToDisplayString() == AttributeFullName);

        List<ArgumentSyntax> arguments =
        [
            Argument(NameOfExpression(propertyName))
                .WithNameColon(NameColon(IdentifierName("name")))
        ];

        if (attribute.TryGetNamedArgument("Getter", out var getter) && getter.Value is string getterName)
        {
            arguments.Add(Argument(IdentifierName(getterName))
                .WithNameColon(NameColon(IdentifierName("getter"))));

            if (attribute.TryGetNamedArgument("Setter", out var setter) && setter.Value is string setterName)
            {
                arguments.Add(Argument(IdentifierName(setterName))
                    .WithNameColon(NameColon(IdentifierName("setter"))));
            }
        }
        else
        {
            arguments.Add(Argument(SimpleLambdaExpression(Parameter(Identifier("o")), MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("o"), IdentifierName(propertyName))))
                .WithNameColon(NameColon(IdentifierName("getter"))));

            if (propertySymbol.SetMethod is not null)
            {
                arguments.Add(Argument(ParenthesizedLambdaExpression(
                        AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("o"), IdentifierName(propertyName)),
                            IdentifierName("v")))
                        .WithParameterList(ParameterList(SeparatedList<ParameterSyntax>([Parameter(Identifier("o")), Parameter(Identifier("v"))]))))
                    .WithNameColon(NameColon(IdentifierName("setter"))));
            }
        }

        if (attribute.TryGetNamedArgument("Coerce", out var coerce))
        {
            arguments.Add(Argument(IdentifierName(coerce.Value!.ToString()))
                .WithNameColon(NameColon(IdentifierName("coerce"))));
        }

        if (attribute.TryGetNamedArgument("EnableDataValidation", out var enableDataValidation))
        {
            arguments.Add(Argument(IdentifierName(enableDataValidation.Value!.ToString().ToLower()))
                .WithNameColon(NameColon(IdentifierName("enableDataValidation"))));
        }

        if (attribute.TryGetNamedArgument("DefaultBindingMode", out var defaultBindingMode))
        {
            arguments.Add(Argument(IdentifierName(TypedConstantInfo.Create(defaultBindingMode).ToString()))
                .WithNameColon(NameColon(IdentifierName("defaultBindingMode"))));
        }

        var fieldDeclaration = FieldDeclaration(
                VariableDeclaration(IdentifierName(directPropertySymbolName))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier($"{propertyName}Property"))
                        .WithInitializer(EqualsValueClause(InvocationExpression(MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(avaloniaPropertySymbolName),
                                GenericName(Identifier("RegisterDirect"))
                                    .AddTypeArgumentListArguments(
                                        IdentifierName(className),
                                        propertySymbol.Type.GetTypeSyntax())))
                            .AddArgumentListArguments([.. arguments]))))))
            .AddModifiers([
                ..propertySymbol.DeclaredAccessibility.GetAccessibilityModifiers(), Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.ReadOnlyKeyword)
            ])
            .AddAttributeLists(AttributeList(SingletonSeparatedList(GeneratedCodeAttribute())))
            .WithLeadingTrivia(ParseLeadingTrivia(
                $$"""
                  /// <summary>
                  /// The backing <see cref="global::Avalonia.DirectProperty{TOwner, TValue}"/> instance for <see cref="{{propertyName}}"/>.
                  /// </summary>

                  """));
        return fieldDeclaration;
    }
}
