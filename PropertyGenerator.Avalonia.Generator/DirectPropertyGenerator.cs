using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PropertyGenerator.Avalonia.Generator.Extensions;
using PropertyGenerator.Avalonia.Generator.Helpers;
using PropertyGenerator.Avalonia.Generator.Models;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static PropertyGenerator.Avalonia.Generator.Helpers.PropertyGenerationHelper;
using PropertyTuple = (Microsoft.CodeAnalysis.IPropertySymbol PropertySymbol, Microsoft.CodeAnalysis.SemanticModel SemanticModel);

namespace PropertyGenerator.Avalonia.Generator;

[Generator]
public class DirectPropertyGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "PropertyGenerator.Avalonia.GeneratedDirectPropertyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var propertySymbols = context.ForAttributeWithMetadataNameAndOptions(
                AttributeFullName,
                predicate: (node, _) => node is PropertyDeclarationSyntax,
                transform: (ctx, _) => (PropertySymbol: (IPropertySymbol) ctx.TargetSymbol, ctx.SemanticModel))
            .Where(ctx => ctx.PropertySymbol.ContainingType is not null);

        var compilationAndProperties = context.CompilationProvider.Combine(propertySymbols.Collect());

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var ctx = source.Right;

            if (ctx.IsDefaultOrEmpty)
                return;

            foreach (var group in ctx.GroupBy<PropertyTuple, INamedTypeSymbol?>(p => p.PropertySymbol.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null)
                    continue;

                if (!DiagnosticHelper.CheckContainingTypeIsPartial(spc, containingClass, "GeneratedDirectPropertyAttribute"))
                    continue;

                if (!DiagnosticHelper.CheckInheritsAvaloniaObject(spc, containingClass, "GeneratedDirectPropertyAttribute"))
                    continue;

                var validProperties = new List<PropertyTuple>();
                foreach (var (property, model) in group)
                {
                    if (!DiagnosticHelper.CheckPropertyDeclaration(spc, property, "GeneratedDirectPropertyAttribute"))
                        continue;

                    var attribute = property.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttributeFullName);
                    if (attribute is null)
                        continue;

                    if (!DiagnosticHelper.CheckDirectPropertyMethodReferences(spc, containingClass, property, attribute))
                        continue;

                    validProperties.Add((property, model));
                }

                if (validProperties.Count == 0)
                    continue;

                var sourceCode = GenerateClassSource(compilation, containingClass, validProperties);
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.Direct.g.cs",
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private static string GenerateClassSource(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var complicationUnit = CompilationUnit()
            .AddMembers(GenerateContent(compilation, classSymbol, properties))
            .WithLeadingTrivia(
                ParseLeadingTrivia("// <auto-generated/>\r\n")
                .Add(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                .Add(Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true))));

        return SyntaxTree(complicationUnit.NormalizeWhitespace()).ToString();
    }

    private static NamespaceDeclarationSyntax GenerateContent(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var doNotGenerateOnPropertyChangedAttributeSymbols = compilation.GetTypesByMetadataName("PropertyGenerator.Avalonia.DoNotGenerateOnPropertyChangedAttribute");
        var generateOnPropertyChanged = !classSymbol.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols)
            && !compilation.Assembly.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols);

        var classDeclaration = ClassDeclaration(className).AddModifiers(Token(SyntaxKind.PartialKeyword));
        foreach (var (property, model) in properties)
        {
            var propertyDeclaration = GenerateProperty(property, model);
            classDeclaration = classDeclaration.AddMembers(GenerateFieldDeclaration(compilation, classSymbol, property, model));
            classDeclaration = classDeclaration.AddMembers(propertyDeclaration);
            if (generateOnPropertyChanged)
                classDeclaration = classDeclaration.AddMembers(GenerateChangedMethod(property));
        }
        classDeclaration = classDeclaration.WithLeadingTrivia(ParseLeadingTrivia($"/// <inheritdoc cref=\"{className}\"/>\r\n"));
        var namespaceDeclarationSyntax = NamespaceDeclaration(ParseName(namespaceName)).AddMembers(classDeclaration);
        return namespaceDeclarationSyntax;
    }

    private static PropertyDeclarationSyntax GenerateProperty(IPropertySymbol propertySymbol, SemanticModel semanticModel)
    {
        var propertyName = propertySymbol.Name;
        var attribute = propertySymbol.GetAttributes().First(p => p.AttributeClass!.ToDisplayString() == AttributeFullName);

        var defaultValue = DefaultValueHelper.GetDefaultValue(attribute, propertySymbol, semanticModel, CancellationToken.None);

        var initializerExpression = defaultValue switch
        {
            AvaloniaPropertyDefaultValue.Callback callback => InvocationExpression(IdentifierName(callback.MethodName)),
            AvaloniaPropertyDefaultValue.Constant => ParseExpression(defaultValue.ToString()),
            _ => null
        };

        var propertyDeclaration = PropertyDeclaration(propertySymbol.Type.GetTypeSyntax(), Identifier(propertyName))
            .AddModifiers(propertySymbol.DeclaredAccessibility.GetAccessibilityModifiers())
            .AddModifiers(Token(SyntaxKind.PartialKeyword));

        if (propertySymbol.GetMethod is { } getMethod)
        {
            var accessDeclaration =
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithExpressionBody(ArrowExpressionClause(IdentifierName("field")))
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
            if (getMethod.DeclaredAccessibility != propertySymbol.DeclaredAccessibility)
                accessDeclaration = accessDeclaration.AddModifiers([..getMethod.DeclaredAccessibility.GetAccessibilityModifiers()]);
            propertyDeclaration = propertyDeclaration.AddAccessorListAccessors(accessDeclaration);
        }

        if (propertySymbol.SetMethod is { } setMethod)
        {
            var accessDeclaration = AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                .WithExpressionBody(ArrowExpressionClause(
                    InvocationExpression(IdentifierName("SetAndRaise"))
                        .AddArgumentListArguments(
                            Argument(IdentifierName($"{propertyName}Property")),
                            Argument(IdentifierName("field")).WithRefOrOutKeyword(Token(SyntaxKind.RefKeyword)),
                            Argument(IdentifierName("value"))
                        )
                )).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
            if (setMethod.DeclaredAccessibility != propertySymbol.DeclaredAccessibility)
                accessDeclaration = accessDeclaration.AddModifiers([.. setMethod.DeclaredAccessibility.GetAccessibilityModifiers()]);
            propertyDeclaration = propertyDeclaration.AddAccessorListAccessors(accessDeclaration);
        }


        if (initializerExpression != null)
        {
            propertyDeclaration = propertyDeclaration.WithInitializer(EqualsValueClause(initializerExpression))
                               .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
        }

        return propertyDeclaration;
    }

    private static FieldDeclarationSyntax GenerateFieldDeclaration(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol, SemanticModel model)
    {
        var propertyName = propertySymbol.Name;
        var className = classSymbol.GetFullyQualifiedName();
        var directPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.DirectProperty`2")!
            .Construct(classSymbol, propertySymbol.Type)
            .GetFullyQualifiedNameWithNullabilityAnnotations();
        var avaloniaPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.AvaloniaProperty")!
            .GetFullyQualifiedName();
        var attribute = propertySymbol.GetAttributes().First(p => p.AttributeClass!.ToDisplayString() == AttributeFullName);

        List<ArgumentSyntax> arguments =
        [
            Argument(NameOfExpression(propertyName))
                .WithNameColon(NameColon(IdentifierName("name")))
        ];

        if (attribute.TryGetNamedArgument("Getter", out var getter) && getter.Value is string getterName)
        {
            arguments.Add(Argument(IdentifierName(getterName))
                .WithNameColon(NameColon(IdentifierName("getter"))));

            if (attribute.TryGetNamedArgument("Setter", out var setter) && setter.Value is string setterName)
            {
                arguments.Add(Argument(IdentifierName(setterName))
                    .WithNameColon(NameColon(IdentifierName("setter"))));
            }
        }
        else
        {
            arguments.Add(Argument(SimpleLambdaExpression(Parameter(Identifier("o")), MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("o"), IdentifierName(propertyName))))
                .WithNameColon(NameColon(IdentifierName("getter"))));

            if (propertySymbol.SetMethod is not null)
            {
                arguments.Add(Argument(ParenthesizedLambdaExpression(
                        AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("o"), IdentifierName(propertyName)),
                            IdentifierName("v")))
                        .WithParameterList(ParameterList(SeparatedList<ParameterSyntax>([Parameter(Identifier("o")), Parameter(Identifier("v"))]))))
                    .WithNameColon(NameColon(IdentifierName("setter"))));
            }
        }

        if (attribute.TryGetNamedArgument("Coerce", out var coerce))
        {
            arguments.Add(Argument(IdentifierName(coerce.Value!.ToString()))
                .WithNameColon(NameColon(IdentifierName("coerce"))));
        }

        if (attribute.TryGetNamedArgument("EnableDataValidation", out var enableDataValidation))
        {
            arguments.Add(Argument(IdentifierName(enableDataValidation.Value!.ToString().ToLower()))
                .WithNameColon(NameColon(IdentifierName("enableDataValidation"))));
        }

        if (attribute.TryGetNamedArgument("DefaultBindingMode", out var defaultBindingMode))
        {
            arguments.Add(Argument(IdentifierName(TypedConstantInfo.Create(defaultBindingMode).ToString()))
                .WithNameColon(NameColon(IdentifierName("defaultBindingMode"))));
        }

        var fieldDeclaration = FieldDeclaration(
                VariableDeclaration(IdentifierName(directPropertySymbolName))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier($"{propertyName}Property"))
                        .WithInitializer(EqualsValueClause(InvocationExpression(MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(avaloniaPropertySymbolName),
                                GenericName(Identifier("RegisterDirect"))
                                    .AddTypeArgumentListArguments(
                                        IdentifierName(className),
                                        propertySymbol.Type.GetTypeSyntax())))
                            .AddArgumentListArguments([.. arguments]))))))
            .AddModifiers([
                ..propertySymbol.DeclaredAccessibility.GetAccessibilityModifiers(), Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.ReadOnlyKeyword)
            ])
            .AddAttributeLists(AttributeList(SingletonSeparatedList(GeneratedCodeAttribute())))
            .WithLeadingTrivia(ParseLeadingTrivia(
                $$"""
                  /// <summary>
                  /// The backing <see cref="global::Avalonia.DirectProperty{TOwner, TValue}"/> instance for <see cref="{{propertyName}}"/>.
                  /// </summary>

                  """));
        return fieldDeclaration;
    }
}
