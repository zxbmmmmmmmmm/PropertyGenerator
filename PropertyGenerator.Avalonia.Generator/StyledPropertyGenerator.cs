using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PropertyGenerator.Avalonia;

namespace PropertyGenerator.Avalonia.Generator;

[Generator]
public class StyledPropertyGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "PropertyGenerator.Avalonia.GeneratedStyledPropertyAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        var propertySymbols = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                predicate: (node, _) => node is PropertyDeclarationSyntax pds && pds.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: (ctx, _) => (IPropertySymbol)ctx.TargetSymbol)
            .Where(symbol => symbol is not null)!;

        var compilationAndProperties = context.CompilationProvider.Combine(propertySymbols.Collect());

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var properties = source.Right;
            
            if (properties.IsDefaultOrEmpty) return;

            foreach (var group in properties.GroupBy<IPropertySymbol, INamedTypeSymbol>(p => p.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null || !InheritsFrom(containingClass, "Avalonia.StyledElement"))
                {
                    continue;
                }
                
                var sourceCode = GenerateClassSource(containingClass, group.ToList());
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.g.cs", 
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }
    
    
    private static string GenerateClassSource(INamedTypeSymbol classSymbol, List<IPropertySymbol> properties)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        var propertiesBuilder = new StringBuilder();
        foreach (var prop in properties)
        {
            propertiesBuilder.Append(GeneratePropertySource(classSymbol, prop));
        }

        return $$"""
                 // <auto-generated/>
                 #nullable enable
                 #pragma warning disable
                 using Avalonia;

                 namespace {{namespaceName}}
                 {
                     public partial class {{className}}
                     {
                 {{propertiesBuilder}}
                     }
                 }
                 """;
    }
    
    private static string GeneratePropertySource(INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol)
    {
        var propertyName = propertySymbol.Name;
        var propertyType = propertySymbol.Type.ToDisplayString();
        var containingClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        
        var attributeData = propertySymbol.GetAttributes().
            First(ad => ad.AttributeClass?.ToDisplayString() == AttributeFullName);
        var defaultValue = "default!";
        
        var defaultValueArg = attributeData.NamedArguments.FirstOrDefault(kvp => kvp.Key == "DefaultValue").Value;
        if (defaultValueArg.Value is not null)
        {
            defaultValue = FormatValue(defaultValueArg);
        }

        return $$"""

                         /// <summary>
                         /// Defines the <see cref="{{propertyName}}"/> styled property.
                         /// </summary>
                         public static readonly StyledProperty<{{propertyType}}> {{propertyName}}Property =
                             AvaloniaProperty.Register<{{containingClassName}}, {{propertyType}}>(
                                 nameof({{propertyName}}),
                                 defaultValue: {{defaultValue}});

                         /// <summary>
                         /// The implementation for the <see cref="{{propertyName}}"/> partial property.
                         /// </summary>
                         public partial {{propertyType}} {{propertyName}}
                         {
                             get => GetValue({{propertyName}}Property);
                             set => SetValue({{propertyName}}Property, value);
                         }
                 """;
    }
    
    private static bool InheritsFrom(INamedTypeSymbol? classSymbol, string baseTypeName)
    {
        var current = classSymbol;
        while (current is not null)
        {
            if (current.BaseType?.ToDisplayString() == baseTypeName)
                return true;
            if (current.ToDisplayString() == baseTypeName)
                return true;
            current = current.BaseType;
        }
        return false;
    }
    
    private static string FormatValue(TypedConstant constant)
    {
        if (constant.IsNull) return "default!";
        
        if (constant.Kind is TypedConstantKind.Enum)
        {
            return $"({constant.Type!.ToDisplayString()}){constant.Value}";
        }
        
        return constant.Type?.SpecialType switch
        {
            SpecialType.System_String => $"\"{constant.Value}\"",
            SpecialType.System_Boolean => constant.Value!.ToString()!.ToLowerInvariant(),
            _ => constant.Value!.ToString()!
        };
    }
}