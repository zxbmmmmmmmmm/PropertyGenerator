using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PropertyGenerator.Avalonia.Generator.Extensions;
using PropertyGenerator.Avalonia.Generator.Models;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using PropertyGenerator.Avalonia.Generator.Helpers;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static PropertyGenerator.Avalonia.Generator.Helpers.PropertyGenerationHelper;
using PropertyTuple = (Microsoft.CodeAnalysis.IPropertySymbol PropertySymbol, Microsoft.CodeAnalysis.SemanticModel SemanticModel);

namespace PropertyGenerator.Avalonia.Generator;

[Generator]
public class StyledPropertyGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "PropertyGenerator.Avalonia.GeneratedStyledPropertyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var propertySymbols = context.ForAttributeWithMetadataNameAndOptions(
                AttributeFullName,
                predicate: (node, _) =>
                {
                    // Initial check that's identical to the analyzer
                    if (!node.IsValidPropertyDeclaration())
                    {
                        return false;
                    }

                    // Make sure that all containing types are partial, otherwise declaring a partial property
                    // would not be valid. We don't need to emit diagnostics here, the compiler will handle that.
                    for (var parentNode = node.FirstAncestor<TypeDeclarationSyntax>();
                         parentNode is not null;
                         parentNode = parentNode.FirstAncestor<TypeDeclarationSyntax>())
                    {
                        if (!parentNode.Modifiers.Any(SyntaxKind.PartialKeyword))
                        {
                            return false;
                        }
                    }

                    // Here we can also easily filter out ref-returning properties just using syntax
                    return !((PropertyDeclarationSyntax) node).Type.IsKind(SyntaxKind.RefType);
                },
                transform: (ctx, _) => (PropertySymbol: (IPropertySymbol) ctx.TargetSymbol, ctx.SemanticModel))
            .Where(ctx => ctx.PropertySymbol.ContainingType is not null);

        var compilationAndProperties = context.CompilationProvider.Combine(propertySymbols.Collect());

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var ctx = source.Right;

            if (ctx.IsDefaultOrEmpty)
                return;

            foreach (var group in ctx.GroupBy<PropertyTuple, INamedTypeSymbol?>(p => p.PropertySymbol.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null || !containingClass.InheritsFromFullyQualifiedMetadataName("Avalonia.AvaloniaObject"))
                {
                    continue;
                }

                var sourceCode = GenerateClassSource(compilation, containingClass, [.. group]);
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.Styled.g.cs",
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private static string GenerateClassSource(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var complicationUnit = CompilationUnit()
            .AddMembers(GenerateContent(compilation, classSymbol, properties))
            .WithLeadingTrivia(
                ParseLeadingTrivia("// <auto-generated/>\r\n")
                .Add(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                .Add(Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true))));

        return SyntaxTree(complicationUnit.NormalizeWhitespace()).ToString();
    }

    private static NamespaceDeclarationSyntax GenerateContent(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var doNotGenerateOnPropertyChangedAttributeSymbols = compilation.GetTypesByMetadataName("PropertyGenerator.Avalonia.DoNotGenerateOnPropertyChangedAttribute");
        var generateOnPropertyChanged = !classSymbol.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols)
            && !compilation.Assembly.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols);

        var classDeclaration = ClassDeclaration(className).AddModifiers(Token(SyntaxKind.PartialKeyword));
        foreach (var (property, model) in properties)
        {
            classDeclaration = classDeclaration.AddMembers(GenerateFieldDeclaration(compilation, classSymbol, property, model));
            classDeclaration = classDeclaration.AddMembers(GeneratePropertyDeclaration(property));
            if (generateOnPropertyChanged)
                classDeclaration = classDeclaration.AddMembers(GenerateChangedMethod(property));
        }
        classDeclaration = classDeclaration.WithLeadingTrivia(ParseLeadingTrivia($"/// <inheritdoc cref=\"{className}\"/>\r\n"));
        var namespaceDeclarationSyntax = NamespaceDeclaration(ParseName(namespaceName)).AddMembers(classDeclaration);
        return namespaceDeclarationSyntax;
    }

    private static FieldDeclarationSyntax GenerateFieldDeclaration(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol, SemanticModel model)
    {
        var propertyName = propertySymbol.Name;
        var className = classSymbol.GetFullyQualifiedName();
        var styledPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.StyledProperty`1")!
            .Construct(propertySymbol.Type).GetFullyQualifiedNameWithNullabilityAnnotations();
        var avaloniaPropertySymbolName =
            compilation.GetTypeByMetadataName("Avalonia.AvaloniaProperty")!.GetFullyQualifiedName();
        var attribute = propertySymbol.GetAttributes().FirstOrDefault(p => p.AttributeClass!.ToDisplayString() == AttributeFullName)!;

        var defaultValue = DefaultValueHelper.GetDefaultValue(
            attribute,
            propertySymbol,
            model,
            CancellationToken.None);

        List<ArgumentSyntax> arguments =
        [
            Argument(NameOfExpression(propertyName))
                .WithNameColon(NameColon(IdentifierName("name")))
        ];

        if (defaultValue is not AvaloniaPropertyDefaultValue.UnsetValue)
        {
            if (defaultValue is AvaloniaPropertyDefaultValue.Callback callback)
            {
                arguments.Add(Argument(InvocationExpression(IdentifierName(callback.MethodName)))
                    .WithNameColon(NameColon(IdentifierName("defaultValue"))));
            }
            else
            {
                arguments.Add(Argument(IdentifierName(defaultValue.ToString()))
                    .WithNameColon(NameColon(IdentifierName("defaultValue"))));
            }
        }

        if (attribute.TryGetNamedArgument("Validate", out var validate))
        {
            arguments.Add(Argument(IdentifierName(validate.Value!.ToString()))
                .WithNameColon(NameColon(IdentifierName("validate"))));
        }

        if (attribute.TryGetNamedArgument("Coerce", out var coerce))
        {
            arguments.Add(Argument(IdentifierName(coerce.Value!.ToString()))
                .WithNameColon(NameColon(IdentifierName("coerce"))));
        }

        if (attribute.TryGetNamedArgument("EnableDataValidation", out var enableDataValidation))
        {
            arguments.Add(Argument(IdentifierName(enableDataValidation.Value!.ToString().ToLower()))
                .WithNameColon(NameColon(IdentifierName("enableDataValidation"))));
        }

        if (attribute.TryGetNamedArgument("Inherits", out var inherits))
        {
            arguments.Add(Argument(IdentifierName(inherits.Value!.ToString().ToLower()))
                .WithNameColon(NameColon(IdentifierName("inherits"))));
        }

        if (attribute.TryGetNamedArgument("DefaultBindingMode", out var defaultBindingMode))
        {
            arguments.Add(Argument(IdentifierName(TypedConstantInfo.Create(defaultBindingMode).ToString()))
                .WithNameColon(NameColon(IdentifierName("defaultBindingMode"))));
        }

        var fieldDeclaration = FieldDeclaration(
                VariableDeclaration(IdentifierName(styledPropertySymbolName))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier($"{propertyName}Property"))
                        .WithInitializer(EqualsValueClause(InvocationExpression(MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(avaloniaPropertySymbolName),
                                GenericName(Identifier("Register"))
                                    .AddTypeArgumentListArguments(
                                        IdentifierName(className),
                                        propertySymbol.Type.GetTypeSyntax())))
                            .AddArgumentListArguments([.. arguments]))))))
            .AddModifiers([
                ..propertySymbol.DeclaredAccessibility.GetAccessibilityModifiers(), Token(SyntaxKind.StaticKeyword),
                Token(SyntaxKind.ReadOnlyKeyword)
            ])
            .AddAttributeLists(AttributeList(SingletonSeparatedList(GeneratedCodeAttribute())))
            .WithLeadingTrivia(ParseLeadingTrivia(
                $$"""
                  /// <summary>
                  /// The backing <see cref="global::Avalonia.StyledProperty{TValue}"/> instance for <see cref="{{propertyName}}"/>.
                  /// </summary>

                  """));
        return fieldDeclaration;
    }
}
