using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;
using PropertyGenerator.Avalonia.Generator.Extensions;
using PropertyGenerator.Avalonia.Generator.Models;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Threading;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace PropertyGenerator.Avalonia.Generator;

[Generator]
public class StyledPropertyGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "PropertyGenerator.Avalonia.GeneratedStyledPropertyAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var propertySymbols = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeFullName,
                predicate: (node, _) => node is PropertyDeclarationSyntax pds && pds.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: (ctx, _) => ctx)
            .Where(ctx => (ctx.TargetSymbol as IPropertySymbol) is not null)!;

        var compilationAndProperties = context.CompilationProvider.Combine(propertySymbols.Collect());

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var ctx = source.Right;
            var properties = ctx.Select(p => p.TargetSymbol as IPropertySymbol)
                .Where(p => p is not null)
                .Cast<IPropertySymbol>()
                .Where(p => p.ContainingType is not null)
                .ToImmutableArray();

            if (properties.IsDefaultOrEmpty) return;
            var model = ctx.First().SemanticModel;

            foreach (var group in properties.GroupBy<IPropertySymbol, INamedTypeSymbol>(p => p.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null || !InheritsFrom(containingClass, "Avalonia.StyledElement"))
                {
                    continue;
                }

                var sourceCode = GenerateClassSource(compilation, containingClass, group.ToList(),model);
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.g.cs", 
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }    
    
    private static string GenerateClassSource(Compilation compilation, INamedTypeSymbol classSymbol, List<IPropertySymbol> properties, SemanticModel model)
    {
        var complicationUnit = CompilationUnit()
            .AddMembers(GenerateContent(compilation, classSymbol, properties, model))
            .WithLeadingTrivia(
                ParseLeadingTrivia("// <auto-generated/>\r\n")
                .Add(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                .Add(Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true))));


        return SyntaxTree(complicationUnit.NormalizeWhitespace()).ToString();
    }

    private static NamespaceDeclarationSyntax GenerateContent(Compilation compilation, INamedTypeSymbol classSymbol, List<IPropertySymbol> properties, SemanticModel model)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var doNotGenerateOnPropertyChangedAttributeSymbols = compilation.GetTypesByMetadataName("PropertyGenerator.Avalonia.DoNotGenerateOnPropertyChangedAttribute");
        var generateOnPropertyChanged = !classSymbol.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols);

        var classDeclaration = ClassDeclaration(className).AddModifiers(Token(SyntaxKind.PartialKeyword));
        foreach (var property in properties)
        {
            classDeclaration = classDeclaration.AddMembers(GenerateFieldDeclaration(compilation, classSymbol, property, model));
            classDeclaration = classDeclaration.AddMembers(GeneratePropertyDeclaration(compilation, classSymbol, property));
            if(generateOnPropertyChanged)
                classDeclaration = classDeclaration.AddMembers(GenerateChangedMethod(compilation, classSymbol, property));
        }
        if (generateOnPropertyChanged)
            classDeclaration = classDeclaration.AddMembers(GenerateOnPropertyChangedOverride(compilation, classSymbol, properties));
        classDeclaration = classDeclaration.WithLeadingTrivia(ParseLeadingTrivia($"/// <inheritdoc cref=\"{className}\"/>\r\n"));
        var namespaceDeclarationSyntax = NamespaceDeclaration(ParseName(namespaceName)).AddMembers(classDeclaration);
        return namespaceDeclarationSyntax;
    }

    private static FieldDeclarationSyntax GenerateFieldDeclaration(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol, SemanticModel model)
    {
        var propertyName = propertySymbol.Name;
        var propertyType = propertySymbol.Type.ToDisplayString();
        var className = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var styledPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.StyledProperty`1")!
            .Construct([propertySymbol.Type], [propertySymbol.NullableAnnotation])
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var avaloniaPropertySymbolName = compilation.GetTypeByMetadataName("Avalonia.AvaloniaProperty")!
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var attribute = propertySymbol.GetAttributes().FirstOrDefault(p =>p.AttributeClass!.ToDisplayString() == AttributeFullName)!;

        var defaultValue = GetDefaultValue(
            attribute,
            propertySymbol,
            classSymbol,
            model,
            CancellationToken.None);

        

        List<ArgumentSyntax> arguments =
        [
            Argument(NameOfExpression(propertyName))
                .WithNameColon(NameColon(IdentifierName("name")))
        ];

        if (defaultValue is not AvaloniaPropertyDefaultValue.UnsetValue)
        {
            if(defaultValue is AvaloniaPropertyDefaultValue.Callback)
            {
                arguments.Add(Argument(InvocationExpression(IdentifierName(defaultValue.ToString())))
                    .WithNameColon(NameColon(IdentifierName("defaultValue"))));
            }
            else
            {
                arguments.Add(Argument(IdentifierName(defaultValue.ToString()))
                    .WithNameColon(NameColon(IdentifierName("defaultValue"))));
            }
        }

        if (attribute.TryGetNamedArgument("Validate", out TypedConstant validate))
        {
            arguments.Add(Argument(IdentifierName(validate.Value!.ToString()))
                .WithNameColon(NameColon(IdentifierName("validate"))));
        }
        
        if (attribute.TryGetNamedArgument("Coerce", out TypedConstant coerce))
        {
            arguments.Add(Argument(IdentifierName(coerce.Value!.ToString()))
                .WithNameColon(NameColon(IdentifierName("coerce"))));
        }

        if (attribute.TryGetNamedArgument("EnableDataValidation", out TypedConstant enableDataValidation))
        {
            arguments.Add(Argument(IdentifierName(enableDataValidation.Value!.ToString().ToLower()))
                .WithNameColon(NameColon(IdentifierName("enableDataValidation"))));
        }

        if (attribute.TryGetNamedArgument("Inherits", out TypedConstant inherits))
        {
            arguments.Add(Argument(IdentifierName(inherits.Value!.ToString().ToLower()))
                .WithNameColon(NameColon(IdentifierName("inherits"))));
        }

        if (attribute.TryGetNamedArgument("DefaultBindingMode", out TypedConstant defaultBindingMode))
        {          
            arguments.Add(Argument(IdentifierName(TypedConstantInfo.Create(defaultBindingMode).ToString()))
                .WithNameColon(NameColon(IdentifierName("defaultBindingMode"))));
        }

        var fieldDeclaration = FieldDeclaration(
                VariableDeclaration(
                        IdentifierName(styledPropertySymbolName))
                    .WithVariables(SingletonSeparatedList(VariableDeclarator(Identifier($"{propertyName}Property"))
                        .WithInitializer(EqualsValueClause(InvocationExpression(MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(avaloniaPropertySymbolName),
                                GenericName(Identifier("Register"))
                                    .AddTypeArgumentListArguments(
                                        IdentifierName(className),
                                        ParseTypeName(propertyType))))
                            .AddArgumentListArguments([..arguments]))))))
            .AddModifiers([..GetAccessibilityModifiers(propertySymbol.DeclaredAccessibility),Token(SyntaxKind.StaticKeyword),Token(SyntaxKind.ReadOnlyKeyword)])
            .AddAttributeLists(
                AttributeList(
                    SingletonSeparatedList(GeneratedCodeAttribute())))
            .WithLeadingTrivia(ParseLeadingTrivia($"/// <summary>\r\n/// The backing <see cref=\"global::Avalonia.StyledProperty{{TValue}}\"/> instance for <see cref=\"{propertyName}\"/>.\r\n/// </summary>\r\n"));
        return fieldDeclaration;
    }

    private static PropertyDeclarationSyntax GeneratePropertyDeclaration(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol)
    {
        var propertyName = propertySymbol.Name;
        var propertyType = propertySymbol.Type.ToDisplayString();

        var propertyDeclaration =
            PropertyDeclaration(ParseTypeName(propertyType), Identifier(propertyName))
                .AddModifiers([..GetAccessibilityModifiers(propertySymbol.DeclaredAccessibility),Token(SyntaxKind.PartialKeyword)])
                .AddAccessorListAccessors(
                    AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithExpressionBody(ArrowExpressionClause(InvocationExpression(IdentifierName("GetValue"))
                            .AddArgumentListArguments(Argument(IdentifierName($"{propertyName}Property")))))
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                    AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                        .WithExpressionBody(ArrowExpressionClause(InvocationExpression(IdentifierName("SetValue"))
                            .AddArgumentListArguments(
                                Argument(IdentifierName($"{propertyName}Property")),
                                Argument(IdentifierName("value")))))
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
                //.WithLeadingTrivia(ParseLeadingTrivia($"/// <inheritdoc cref=\"{propertyName}\"/>\r\n"));

        return propertyDeclaration;
    }

    private static MethodDeclarationSyntax GenerateOnPropertyChangedOverride(Compilation compilation, INamedTypeSymbol classSymbol, List<IPropertySymbol> properties)
    {

        var switchStatement =
            SwitchStatement(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName("change"),
                        IdentifierName("Property")),
                    IdentifierName("Name")));
        foreach (var property in properties)
        {
            var propertyName = property.Name;
            var propertyType = property.Type.ToDisplayString();

            switchStatement = switchStatement
                .AddSections(
                        SwitchSection()
                        .AddLabels(CaseSwitchLabel(
                            InvocationExpression(
                                    IdentifierName(
                                        Identifier(
                                            TriviaList(),
                                            SyntaxKind.NameOfKeyword,
                                            "nameof",
                                            "nameof",
                                            TriviaList())))
                                .AddArgumentListArguments(
                                    Argument(IdentifierName(propertyName)))))
                        .AddStatements(
                            ExpressionStatement(
                                InvocationExpression(
                                        IdentifierName($"On{propertyName}PropertyChanged"))
                                    .AddArgumentListArguments(Argument(IdentifierName("change")))),
                                    ExpressionStatement(
                                        InvocationExpression(
                                            IdentifierName($"On{propertyName}PropertyChanged"))
                                        .AddArgumentListArguments(Argument(
                                            CastExpression(IdentifierName(propertyType),
                                                MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    IdentifierName("change"),
                                                    IdentifierName("NewValue")))))),
                                    ExpressionStatement(
                                        InvocationExpression(
                                            IdentifierName($"On{propertyName}PropertyChanged"))
                                        .AddArgumentListArguments(
                                                        Argument(
                                                            CastExpression(
                                                                IdentifierName(propertyType),
                                                                MemberAccessExpression(
                                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                                    IdentifierName("change"),
                                                                    IdentifierName("OldValue")))),
                                                        Argument(
                                                            CastExpression(
                                                                IdentifierName(propertyType),
                                                                MemberAccessExpression(
                                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                                    IdentifierName("change"),
                                                                    IdentifierName("NewValue")))))),
                                    BreakStatement()));

        }
        var methodDeclaration = MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.VoidKeyword)),
                Identifier("OnPropertyChanged"))
            .AddModifiers(Token(SyntaxKind.ProtectedKeyword),
                Token(SyntaxKind.OverrideKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("change"))
                    .WithType(IdentifierName("global::Avalonia.AvaloniaPropertyChangedEventArgs")))
            .WithBody(
                Block(
                    ExpressionStatement(
                        InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    BaseExpression(),
                                    IdentifierName("OnPropertyChanged")))
                            .AddArgumentListArguments(
                                Argument(
                                    IdentifierName("change")))),
                    switchStatement
                ));
        return methodDeclaration;
    }

    private static MemberDeclarationSyntax[] GenerateChangedMethod(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol)
    {
        var propertyName = propertySymbol.Name;

        var methodDeclaration = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier($"On{propertyName}PropertyChanged"))
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("newValue"))
                    .WithType(IdentifierName(propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken))
            .AddAttributeLists(
                AttributeList(
                    SingletonSeparatedList(GeneratedCodeAttribute())));

        var methodDeclarationWithOldValue = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier($"On{propertyName}PropertyChanged"))
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("oldValue"))
                    .WithType(IdentifierName(propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))),
                Parameter(Identifier("newValue"))
                    .WithType(IdentifierName(propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            .AddAttributeLists(
                AttributeList(
                    SingletonSeparatedList(GeneratedCodeAttribute())));

        var methodDeclarationWithArgs = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier($"On{propertyName}PropertyChanged"))
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("e"))
                    .WithType(IdentifierName("global::Avalonia.AvaloniaPropertyChangedEventArgs")))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            .AddAttributeLists(
                AttributeList(
                    SingletonSeparatedList(GeneratedCodeAttribute())));
        return [methodDeclaration,methodDeclarationWithOldValue, methodDeclarationWithArgs];
    }


    private static MethodDeclarationSyntax GenerateGetMethod(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol)
    {
        var propertyName = propertySymbol.Name;

        var onGet = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier($"On{propertyName}Get"))
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("propertyValue"))
                    .WithModifiers(TokenList(Token(SyntaxKind.RefKeyword)))
                    .WithType(IdentifierName(propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken))
            .AddAttributeLists(
                AttributeList(
                    SingletonSeparatedList(GeneratedCodeAttribute())));
        return onGet;
    }

    private static MethodDeclarationSyntax GenerateSetMethod(Compilation compilation, INamedTypeSymbol classSymbol, IPropertySymbol propertySymbol)
    {
        var propertyName = propertySymbol.Name;

        var onSet = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier($"On{propertyName}Set"))
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("propertyValue"))
                    .WithModifiers(TokenList(Token(SyntaxKind.RefKeyword)))
                    .WithType(IdentifierName(propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken))
            .AddAttributeLists(
                AttributeList(
                    SingletonSeparatedList(GeneratedCodeAttribute())));
        return onSet;
    }

    private static NamespaceDeclarationSyntax GeneratePropertyChangedCallbacks(Compilation compilation, INamedTypeSymbol classSymbol, List<IPropertySymbol> properties)
    {

        var callbacksClassDeclaration = ClassDeclaration("PropertyChangedCallbacks").AddModifiers(Token(SyntaxKind.FileKeyword), Token(SyntaxKind.SealedKeyword));
        callbacksClassDeclaration = callbacksClassDeclaration
            .AddMembers(
                FieldDeclaration(
                        VariableDeclaration(IdentifierName("PropertyChangedCallbacks"))
                            .AddVariables(
                                VariableDeclarator(Identifier("Instance")).WithInitializer(EqualsValueClause(ImplicitObjectCreationExpression()))))
                    .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

        foreach (var property in properties)
        {
            callbacksClassDeclaration = callbacksClassDeclaration
                .AddMembers(GeneratePropertyChangedMethod(property));
        }


        var namespaceDeclarationSyntax = NamespaceDeclaration(IdentifierName("PropertyGenerator.Avalonia.Generator"))
            .AddUsings(UsingDirective(IdentifierName("global::System.Runtime.CompilerServices")))
            .AddUsings(UsingDirective(IdentifierName("global::Avalonia")))
            .AddMembers(callbacksClassDeclaration);
        return namespaceDeclarationSyntax;
    }

    private static MethodDeclarationSyntax GeneratePropertyChangedMethod(IPropertySymbol propertySymbol)
    {
        var propertyName = propertySymbol.Name;
        var methodDeclaration = MethodDeclaration(IdentifierName("PropertyChangedCallback"), Identifier(propertyName))
            .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword))
            .AddBodyStatements(
            ReturnStatement(
                ImplicitObjectCreationExpression()
                .AddArgumentListArguments(
                    Argument(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName("Instance"),
                            IdentifierName($"On{propertyName}PropertyChanged"))))));
        return methodDeclaration;
    }

    private static AttributeSyntax GeneratedCodeAttribute()
    {
        return Attribute(IdentifierName("global::System.CodeDom.Compiler.GeneratedCode"))
            .AddArgumentListArguments(
                AttributeArgument(LiteralExpression(
                    SyntaxKind.StringLiteralExpression,
                    Literal("PropertyGenerator.Avalonia.Generator"))),
                AttributeArgument(LiteralExpression(
                    SyntaxKind.StringLiteralExpression,
                    Literal("1.0.0.0"))));
    }

    private static AvaloniaPropertyDefaultValue GetDefaultValue(
        AttributeData attributeData,
        IPropertySymbol propertySymbol,
        ITypeSymbol? metadataTypeSymbol,
        SemanticModel semanticModel,
        CancellationToken token)
    {
        // First, check if we have a callback
        if (attributeData.TryGetNamedArgument("DefaultValueCallback", out TypedConstant defaultValueCallback))
        {
            // This must be a valid 'string' value
            if (defaultValueCallback is { Type.SpecialType: SpecialType.System_String, Value: string { Length: > 0 } methodName })
            {
                // Check that we can find a potential candidate callback method
                if (TryFindDefaultValueCallbackMethod(propertySymbol, methodName, out IMethodSymbol? methodSymbol))
                {
                    // Validate the method has a valid signature as well
                    if (IsDefaultValueCallbackValid(propertySymbol, methodSymbol))
                    {
                        return new AvaloniaPropertyDefaultValue.Callback(methodName);
                    }
                }
            }

            // Invalid callback, the analyzer will emit an error
            return AvaloniaPropertyDefaultValue.Null.Instance;
        }

        token.ThrowIfCancellationRequested();
        var hasDefaultValue = attributeData.TryGetConstructorArgument(0, out TypedConstant defaultValue);
        if (!hasDefaultValue)
        {
            hasDefaultValue = attributeData.TryGetNamedArgument("DefaultValue", out defaultValue);
        }
        // Next, check whether the default value is explicitly set or not
        if (hasDefaultValue)
        {
            // If the explicit value is anything other than 'null', we can return it directly
            if (!defaultValue.IsNull)
            {
                return new AvaloniaPropertyDefaultValue.Constant(TypedConstantInfo.Create(defaultValue));
            }

            // If we do have a default value, we also want to check whether it's the special 'UnsetValue' placeholder.
            // To do so, we get the application syntax, find the argument, then get the operation and inspect it.
            if (attributeData.ApplicationSyntaxReference?.GetSyntax(token) is AttributeSyntax attributeSyntax)
            {
                foreach (AttributeArgumentSyntax attributeArgumentSyntax in attributeSyntax.ArgumentList?.Arguments ?? [])
                {
                    // Let's see whether the current argument is the one that set the 'DefaultValue' property
                    if (attributeArgumentSyntax.NameEquals?.Name.Identifier.Text is "DefaultValue")
                    {
                        IOperation? operation = semanticModel.GetOperation(attributeArgumentSyntax.Expression, token);

                        // Double check that it's a constant field reference (it could also be a literal of some kind, etc.)
                        if (operation is IFieldReferenceOperation { Field: { Name: "UnsetValue" } fieldSymbol })
                        {
                            // Last step: we want to validate that the reference is actually to the special placeholder
                            //if (fieldSymbol.ContainingType!.HasFullyQualifiedMetadataName(WellKnownTypeNames.GeneratedDependencyProperty))
                            //{
                                return new AvaloniaPropertyDefaultValue.UnsetValue();
                            //}
                        }
                    }
                }
            }

            // Otherwise, the value has been explicitly set to 'null', so let's respect that
            return AvaloniaPropertyDefaultValue.Null.Instance;
        }

        token.ThrowIfCancellationRequested();

        // In all other cases, we'll automatically use the default value of the type in question.
        // First we need to special case non nullable values, as for those we need 'default'.
        if (!propertySymbol.Type.IsDefaultValueNull())
        {
            // We need special logic to handle cases where the metadata type is different. For instance,
            // the XAML initialization won't work if the metadata type on a property is just 'object'.
            ITypeSymbol effectiveMetadataTypeSymbol = metadataTypeSymbol ?? propertySymbol.Type;

            // For non nullable types, we return 'default(T)', unless we can optimize for projected types
            return new AvaloniaPropertyDefaultValue.Default(
                TypeName: propertySymbol.Type.GetFullyQualifiedName());
        }

        // For all other ones, we can just use the 'null' placeholder again
        return AvaloniaPropertyDefaultValue.Null.Instance;
    }



    /// <summary>
    /// Tries to find a candidate default value callback method for a given property.
    /// </summary>
    /// <param name="propertySymbol">The <see cref="IPropertySymbol"/> currently being targeted by the analyzer.</param>
    /// <param name="methodName">The name of the default value callback method to look for.</param>
    /// <param name="methodSymbol">The <see cref="IMethodSymbol"/> for the resulting default value callback candidate method, if found.</param>
    /// <returns>Whether <paramref name="methodSymbol"/> could be found.</returns>
    public static bool TryFindDefaultValueCallbackMethod(IPropertySymbol propertySymbol, string methodName, [NotNullWhen(true)] out IMethodSymbol? methodSymbol)
    {
        ImmutableArray<ISymbol> memberSymbols = propertySymbol.ContainingType!.GetMembers(methodName);

        foreach (ISymbol member in memberSymbols)
        {
            // Ignore all other member types
            if (member is not IMethodSymbol candidateSymbol)
            {
                continue;
            }

            // Match the exact method name too
            if (candidateSymbol.Name == methodName)
            {
                methodSymbol = candidateSymbol;

                return true;
            }
        }

        methodSymbol = null;

        return false;
    }

    /// <summary>
    /// Checks whether a given default value callback method is valid for a given property.
    /// </summary>
    /// <param name="propertySymbol">The <see cref="IPropertySymbol"/> currently being targeted by the analyzer.</param>
    /// <param name="methodSymbol">The <see cref="IMethodSymbol"/> for the candidate default value callback method to validate.</param>
    /// <returns>Whether <paramref name="methodSymbol"/> is a valid default value callback method for <paramref name="propertySymbol"/>.</returns>
    public static bool IsDefaultValueCallbackValid(IPropertySymbol propertySymbol, IMethodSymbol methodSymbol)
    {
        // We need methods which are static and with no parameters (and that are not explicitly implemented)
        if (methodSymbol is not { IsStatic: true, Parameters: [], ExplicitInterfaceImplementations: [] })
        {
            return false;
        }

        // We have a candidate, now we need to match the return type. First,
        // we just check whether the return is 'object', or an exact match.
        if (methodSymbol.ReturnType.SpecialType is SpecialType.System_Object ||
            SymbolEqualityComparer.Default.Equals(propertySymbol.Type, methodSymbol.ReturnType))
        {
            return true;
        }

        // Otherwise, try to see if the return is the type argument of a nullable value type
        return propertySymbol.Type.IsNullableValueTypeWithUnderlyingType(methodSymbol.ReturnType);
    }


    private static bool InheritsFrom(INamedTypeSymbol? classSymbol, string baseTypeName)
    {
        var current = classSymbol;
        while (current is not null)
        {
            if (current.BaseType?.ToDisplayString() == baseTypeName)
                return true;
            if (current.ToDisplayString() == baseTypeName)
                return true;
            current = current.BaseType;
        }
        return false;
    }

    private static SyntaxToken[] GetAccessibilityModifiers(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => [Token(SyntaxKind.PublicKeyword)],
            Accessibility.Protected => [Token(SyntaxKind.ProtectedKeyword)],
            Accessibility.Internal => [Token(SyntaxKind.InternalKeyword)],
            Accessibility.ProtectedOrInternal => [Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ProtectedKeyword)],
            Accessibility.ProtectedAndInternal => [Token(SyntaxKind.ProtectedKeyword), Token(SyntaxKind.InternalKeyword)],
            Accessibility.Private => [Token(SyntaxKind.PrivateKeyword)],
            _ => [],
        };
    }

    /// <summary>
    /// Generate the following code
    /// <code>
    /// nameof(<paramref name="name" />)
    /// </code>
    /// </summary>
    /// <returns>NameOfExpression</returns>
    internal static InvocationExpressionSyntax NameOfExpression(string name) => NameOfExpression(IdentifierName(name));

    /// <summary>
    /// Generate the following code
    /// <code>
    /// nameof(<paramref name="expressionSyntax" />)
    /// </code>
    /// </summary>
    /// <returns>NameOfExpression</returns>
    internal static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expressionSyntax) => InvocationExpression(IdentifierName("nameof"), ArgumentList().AddArguments(Argument(expressionSyntax)));
}