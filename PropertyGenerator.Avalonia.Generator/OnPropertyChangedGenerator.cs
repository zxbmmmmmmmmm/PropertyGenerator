using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PropertyGenerator.Avalonia.Generator.Extensions;
using PropertyGenerator.Avalonia.Generator.Helpers;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static PropertyGenerator.Avalonia.Generator.Helpers.PropertyGenerationHelper;
using PropertyTuple = (Microsoft.CodeAnalysis.IPropertySymbol PropertySymbol, Microsoft.CodeAnalysis.SemanticModel);

namespace PropertyGenerator.Avalonia.Generator;

[Generator]
public class OnPropertyChangedGenerator : IIncrementalGenerator
{
    private const string DirectAttributeFullName = "PropertyGenerator.Avalonia.GeneratedDirectPropertyAttribute";
    private const string StyledAttributeFullName = "PropertyGenerator.Avalonia.GeneratedStyledPropertyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var directPropertySymbols = context.ForAttributeWithMetadataNameAndOptions(
                DirectAttributeFullName,
                predicate: (node, _) => node.IsValidPropertyDeclaration(),
                transform: (ctx, _) => (PropertySymbol: (IPropertySymbol)ctx.TargetSymbol, ctx.SemanticModel))
            .Where(ctx => ctx.PropertySymbol.ContainingType is not null);

        var styledPropertySymbols = context.ForAttributeWithMetadataNameAndOptions(
                StyledAttributeFullName,
                predicate: (node, _) => node.IsValidPropertyDeclaration(),
                transform: (ctx, _) => (PropertySymbol: (IPropertySymbol)ctx.TargetSymbol, ctx.SemanticModel))
            .Where(ctx => ctx.PropertySymbol.ContainingType is not null);

        var combinedProperties = directPropertySymbols.Collect().Combine(styledPropertySymbols.Collect());

        var compilationAndProperties = context.CompilationProvider.Combine(combinedProperties);

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var (directProps, styledProps) = source.Right;

            if (directProps.IsDefaultOrEmpty && styledProps.IsDefaultOrEmpty)
                return;

            var allProperties = directProps.Concat(styledProps).ToList();

            foreach (var group in allProperties.GroupBy<PropertyTuple, INamedTypeSymbol?>(p => p.PropertySymbol.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null || !containingClass.InheritsFromFullyQualifiedMetadataName("Avalonia.AvaloniaObject"))
                {
                    continue;
                }

                var doNotGenerateOnPropertyChangedAttributeSymbols = compilation.GetTypesByMetadataName("PropertyGenerator.Avalonia.DoNotGenerateOnPropertyChangedAttribute");
                var generateOnPropertyChanged = !containingClass.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols)
                                                  && !compilation.Assembly.HasAttributeWithAnyType(doNotGenerateOnPropertyChangedAttributeSymbols);

                if (!generateOnPropertyChanged)
                {
                    continue;
                }

                var currentDirectProps = group.Where(p => p.PropertySymbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == DirectAttributeFullName)).ToList();
                var currentStyledProps = group.Where(p => p.PropertySymbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == StyledAttributeFullName)).ToList();

                var sourceCode = GenerateClassSource(containingClass, currentStyledProps, currentDirectProps);
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.OnPropertyChanged.g.cs",
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private static string GenerateClassSource(INamedTypeSymbol classSymbol, ICollection<PropertyTuple> styledProperties, ICollection<PropertyTuple> directProperties)
    {
        var complicationUnit = CompilationUnit()
            .AddMembers(GenerateContent(classSymbol, styledProperties, directProperties))
            .WithLeadingTrivia(
                ParseLeadingTrivia("// <auto-generated/>\r\n")
                .Add(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                .Add(Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true))));

        return SyntaxTree(complicationUnit.NormalizeWhitespace()).ToString();
    }

    private static NamespaceDeclarationSyntax GenerateContent(INamedTypeSymbol classSymbol, ICollection<PropertyTuple> styledProperties, ICollection<PropertyTuple> directProperties)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        var classDeclaration = ClassDeclaration(className)
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateOnPropertyChangedOverride(styledProperties, directProperties))
            .WithLeadingTrivia(ParseLeadingTrivia($"/// <inheritdoc cref=\"{className}\"/>\r\n"));

        return NamespaceDeclaration(ParseName(namespaceName)).AddMembers(classDeclaration);
    }

    private static MethodDeclarationSyntax GenerateOnPropertyChangedOverride(
        ICollection<PropertyTuple> styledProperties,
        ICollection<PropertyTuple> directProperties)
    {
        var changeIdentifier = IdentifierName("change");
        var propertyNameAccess = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                changeIdentifier,
                IdentifierName("Property")),
            IdentifierName("Name"));

        var switchSections = styledProperties.Concat(directProperties)
            .Select(p =>
            {
                var propertyName = p.PropertySymbol.Name;
                var propertyType = p.PropertySymbol.Type;
                var typeSyntax = propertyType.GetTypeSyntax();

                var oldValueAccess = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, changeIdentifier, IdentifierName("OldValue"));
                var newValueAccess = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, changeIdentifier, IdentifierName("NewValue"));

                var oldValueArg = Argument(CastExpression(typeSyntax, oldValueAccess));
                var newValueArg = Argument(CastExpression(typeSyntax, newValueAccess));

                if (propertyType.IsValueType && propertyType.NullableAnnotation != NullableAnnotation.Annotated)
                {
                    oldValueArg = Argument(CastExpression(typeSyntax, SuppressNullableWarningExpression(oldValueAccess)));
                    newValueArg = Argument(CastExpression(typeSyntax, SuppressNullableWarningExpression(newValueAccess)));
                }

                return SwitchSection()
                    .AddLabels(
                        CaseSwitchLabel(
                            InvocationExpression(IdentifierName("nameof"))
                                .AddArgumentListArguments(Argument(IdentifierName(propertyName)))))
                    .AddStatements(
                        ExpressionStatement(
                            InvocationExpression(IdentifierName($"On{propertyName}PropertyChanged"))
                                .AddArgumentListArguments(Argument(changeIdentifier))),
                        ExpressionStatement(
                            InvocationExpression(IdentifierName($"On{propertyName}PropertyChanged"))
                                .AddArgumentListArguments(newValueArg)),
                        ExpressionStatement(
                            InvocationExpression(IdentifierName($"On{propertyName}PropertyChanged"))
                                .AddArgumentListArguments(oldValueArg, newValueArg)),
                        BreakStatement());
            })
            .ToArray();

        return MethodDeclaration(
                PredefinedType(Token(SyntaxKind.VoidKeyword)),
                Identifier("OnPropertyChanged"))
            .AddModifiers(
                Token(SyntaxKind.ProtectedKeyword),
                Token(SyntaxKind.OverrideKeyword))
            .AddParameterListParameters(
                Parameter(Identifier("change"))
                    .WithType(IdentifierName("global::Avalonia.AvaloniaPropertyChangedEventArgs")))
            .WithBody(
                Block(
                    ExpressionStatement(
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                BaseExpression(),
                                IdentifierName("OnPropertyChanged")))
                            .AddArgumentListArguments(Argument(changeIdentifier))),
                    SwitchStatement(propertyNameAccess)
                        .AddSections(switchSections)))
            .AddAttributeLists(AttributeList(SingletonSeparatedList(GeneratedCodeAttribute())));
    }
}
